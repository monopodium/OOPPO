# 重要源文件

### 1. client.h/cpp
client通过set和get两个接口来存储数据和读取数据。
```c
/*
	步骤：
	     1）调用uploadOriginKeyValue；
	     2）向指定的proxy节点发送value；
	     3）向coordinator询问value是否已经成功存储到datanode上；
*/
bool Client::set(std::string key, std::string value)
```
```c
/*
	步骤：
	     1）调用getValue；
	     2）阻塞等待接收proxy发来的数据；
*/
bool Client::get(std::string key, std::string &value)
```

### 2. coordinator.h/cpp
coordinator中的实现函数基本都是rpc，由其它节点远程调用。
```c
/* 
   调用节点：client
   执行节点：coordinator
   rpc参数：k、l、g、编码策略、放置策略、blob上限、小文件上限的系统参数
   rpc返回值：bool值，指示系统参数是否设置成功
   作用：在coordinator中设置各种系统参数。
   备注：在client进程启动时便会调用。
*/
grpc::Status CoordinatorImpl::setParameter(::grpc::ServerContext *context, const coordinator_proto::Parameter *parameter, coordinator_proto::RepIfSetParaSucess *setParameterReply)
```
```c
/* 
   调用节点：client
   执行节点：coordinator
   rpc参数：key，value大小
   rpc返回值：proxy的ip和端口号
   作用：在coordinator中为key对应的对象构造并保存相应的元数据信息，生成该对象数据的放置策略，
        指定一个proxy节点做好接收数据的准备工作，并向client返回该proxy节点的地址。
*/
grpc::Status CoordinatorImpl::uploadOriginKeyValue(::grpc::ServerContext *context, const coordinator_proto::RequestProxyIPPort *keyValueSize, coordinator_proto::ReplyProxyIPPort *proxyIPPort)
```
```c
/* 
   调用节点：client
   执行节点：coordinator
   rpc参数：key，client的ip和端口号
   rpc返回值：读取到的数据的大小
   作用：根据key，coordinator将一些必要的元数据信息发送给某一proxy节点，
        指示该proxy从datanode读取数据并发送给client。
*/
grpc::Status CoordinatorImpl::getValue(::grpc::ServerContext *context, const coordinator_proto::KeyAndClientIP *keyClient, coordinator_proto::RepIfGetSucess *getReplyClient)
```

```c
/* 
   调用节点：client
   执行节点：coordinator
   rpc参数：key
   rpc返回值：数据存储结果
   作用：client向coordinator查询，本次set操作中，key对应的对象数据是否已经成功存储到了datanode中。
*/
grpc::Status CoordinatorImpl::checkCommitAbort(grpc::ServerContext *context, const coordinator_proto::AskIfSetSucess *key, coordinator_proto::RepIfSetSucess *reply)
```

```c
/* 
   调用节点：proxy
   执行节点：coordinator
   rpc参数：key，数据存储结果
   rpc返回值：无
   作用：proxy告知coordinator，key所对应的对象的数据是否都已经完全存储到了datanode中。
*/
grpc::Status CoordinatorImpl::reportCommitAbort(::grpc::ServerContext *context, const coordinator_proto::CommitAbortKey *commit_abortkey, coordinator_proto::ReplyFromCoordinator *helloReplyFromCoordinator)
```
```c
// 根据预先设定的编码策略、编码参数、放置策略等条件，为每个条带生成具体的放置方案。
void CoordinatorImpl::generate_placement(std::vector<unsigned int> &stripe_nodes)
```

### 3. proxy.h/cpp
proxy主要由2个rpc调用实现自身的功能。
```c
/* 
   调用节点：coordinator
   执行节点：proxy
   rpc参数：各种系统参数以及实际的放置方案
   rpc返回值：无
   作用：在proxy中启动1个异步线程，然后该rpc调用就立刻结束返回，
        新启动的线程会等待client发送过来的数据，当接收到client的数据后，
        根据coordinator给出的各种系统参数，对数据进行切片、编码等操作，
        最后根据coordinator给出的放置方案将数据块和校验块存储到datanode中。
*/
grpc::Status ProxyImpl::EncodeAndSetObject(grpc::ServerContext *context, const proxy_proto::ObjectAndPlacement *object_and_placement, proxy_proto::SetReply *response)
```
```c
/* 
   调用节点：coordinator
   执行节点：proxy
   rpc参数：各种系统参数、实际的放置方案以及client的ip和端口号
   rpc返回值：无
   作用：在proxy中启动1个异步线程，然后该rpc调用就立刻结束返回，
        新启动的线程会从datanode中读取各个块并解码合并得到原始数据
        将数据发送给client。
*/
grpc::Status ProxyImpl::decodeAndGetObject(grpc::ServerContext *context, const proxy_proto::ObjectAndPlacement *object_and_placement, proxy_proto::GetReply *response)
```

### 4. datanode.h/cpp
datanode很简单，只有1个do_work函数，其作用就是阻塞等待来自proxy的读写数据请求。
```c
void DataNode::do_work()
```
# 函数调用关系
### 1. 大文件读
![大文件读](./pics/func_desc_bigget.jpeg "大文件读")
### 2. 大文件写
![大文件写](./pics/func_desc_bigset.jpeg "大文件写")
